<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Synthesis · ControlSystems.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="ControlSystems.jl logo"/></a><h1>ControlSystems.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/example/">Design</a></li></ul></li><li><span class="toctext">Guide</span><ul><li><a class="toctext" href="../../man/introduction/">Introduction</a></li><li><a class="toctext" href="../../man/creatingtfs/">Creating Transfer Functions</a></li></ul></li><li><span class="toctext">Functions</span><ul><li><a class="toctext" href="../constructors/">Constructors</a></li><li><a class="toctext" href="../analysis/">Analysis</a></li><li class="current"><a class="toctext" href>Synthesis</a><ul class="internal"></ul></li><li><a class="toctext" href="../timefreqresponse/">Time and Frequency response</a></li><li><a class="toctext" href="../plotting/">Plotting</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Functions</li><li><a href>Synthesis</a></li></ul><a class="edit-page" href="https://github.com/JuliaControl/ControlSystems.jl/blob/master/docs/src/lib/synthesis.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Synthesis</span><a class="fa fa-bars" href="#"></a></div></header><ul><li><a href="#ControlSystems.balance"><code>ControlSystems.balance</code></a></li><li><a href="#ControlSystems.care"><code>ControlSystems.care</code></a></li><li><a href="#ControlSystems.dab"><code>ControlSystems.dab</code></a></li><li><a href="#ControlSystems.dare"><code>ControlSystems.dare</code></a></li><li><a href="#ControlSystems.dkalman"><code>ControlSystems.dkalman</code></a></li><li><a href="#ControlSystems.dlqr"><code>ControlSystems.dlqr</code></a></li><li><a href="#ControlSystems.dlyap"><code>ControlSystems.dlyap</code></a></li><li><a href="#ControlSystems.kalman"><code>ControlSystems.kalman</code></a></li><li><a href="#ControlSystems.laglink"><code>ControlSystems.laglink</code></a></li><li><a href="#ControlSystems.leadlink"><code>ControlSystems.leadlink</code></a></li><li><a href="#ControlSystems.leadlinkat"><code>ControlSystems.leadlinkat</code></a></li><li><a href="#ControlSystems.loopshapingPI"><code>ControlSystems.loopshapingPI</code></a></li><li><a href="#ControlSystems.lqr"><code>ControlSystems.lqr</code></a></li><li><a href="#ControlSystems.pid"><code>ControlSystems.pid</code></a></li><li><a href="#ControlSystems.place"><code>ControlSystems.place</code></a></li><li><a href="#ControlSystems.reduce_sys"><code>ControlSystems.reduce_sys</code></a></li><li><a href="#ControlSystems.rstc"><code>ControlSystems.rstc</code></a></li><li><a href="#ControlSystems.rstd"><code>ControlSystems.rstd</code></a></li></ul><h1><a class="nav-anchor" id="Synthesis-1" href="#Synthesis-1">Synthesis</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.balance" href="#ControlSystems.balance"><code>ControlSystems.balance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>S, P, B = balance(A[, perm=true])</code></p><p>Compute a similarity transform <code>T</code> resulting in <code>B = T\A*T</code> such that the row and column norms of <code>B</code> are approximately equivalent. If <code>perm=false</code>, the transformation will only scale <code>A</code> using diagonal <code>S</code>, and not permute <code>A</code> (i.e., set <code>P=I</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/matrix_comps.jl#L398-L403">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.care" href="#ControlSystems.care"><code>ControlSystems.care</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>care(A, B, Q, R)</code></p><p>Compute &#39;X&#39;, the solution to the continuous-time algebraic Riccati equation, defined as A&#39;X + XA - (XB)R^-1(B&#39;X) + Q = 0, where R is non-singular.</p><p>Algorithm taken from: Laub, &quot;A Schur Method for Solving Algebraic Riccati Equations.&quot; http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/matrix_comps.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dab" href="#ControlSystems.dab"><code>ControlSystems.dab</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>DAB   Solves the Diophantine-Aryabhatta-Bezout identity</p><p><code>X,Y = DAB(A,B,C)</code></p><p>AX + BY = C, where A, B, C, X and Y are polynomials and deg Y = deg A - 1.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/discrete.jl#L108-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dare" href="#ControlSystems.dare"><code>ControlSystems.dare</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dare(A, B, Q, R)</code></p><p>Compute <code>X</code>, the solution to the discrete-time algebraic Riccati equation, defined as A&#39;XA - X - (A&#39;XB)(B&#39;XB + R)^-1(B&#39;XA) + Q = 0, where A and R are non-singular.</p><p>Algorithm taken from: Laub, &quot;A Schur Method for Solving Algebraic Riccati Equations.&quot; http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/matrix_comps.jl#L34-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dkalman" href="#ControlSystems.dkalman"><code>ControlSystems.dkalman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dkalman(A, C, R1, R2)</code> kalman(sys, R1, R2)`</p><p>Calculate the optimal Kalman gain for discrete time systems</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/synthesis.jl#L107-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dlqr" href="#ControlSystems.dlqr"><code>ControlSystems.dlqr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dlqr(A, B, Q, R)</code>, <code>dlqr(sys, Q, R)</code></p><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u[k] = K*x[k]</code> that minimizes the cost function:</p><p>J = sum(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the discrte time model <code>x[k+1] = Ax[k] + Bu[k]</code>.</p><p>See also <code>lqg</code></p><p>Usage example:</p><pre><code class="language-julia">using LinearAlgebra # For identity matrix I
h = 0.1
A = [1 h; 0 1]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0, h)
Q = I
R = I
L = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used

u(t,x) = -L*x # Form control law,
t=0:h:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0)
plot(t,x, lab=[&quot;Position&quot;, &quot;Velocity&quot;]&#39;, xlabel=&quot;Time [s]&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/synthesis.jl#L67-L97">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.dlyap" href="#ControlSystems.dlyap"><code>ControlSystems.dlyap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>dlyap(A, Q)</code></p><p>Compute the solution <code>X</code> to the discrete Lyapunov equation <code>AXA&#39; - X + Q = 0</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/matrix_comps.jl#L70-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.kalman" href="#ControlSystems.kalman"><code>ControlSystems.kalman</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>kalman(A, C, R1, R2)</code> kalman(sys, R1, R2)`</p><p>Calculate the optimal Kalman gain</p><p>See also <code>LQG</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/synthesis.jl#L41-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.laglink" href="#ControlSystems.laglink"><code>ControlSystems.laglink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>laglink(a, M; h=0)</code></p><p>Returns a phase retarding link, the rule of thumb <code>a = 0.1ωc</code> guarantees less than 6 degrees phase margin loss. The bode curve will go from <code>M</code>, bend down at <code>a/M</code> and level out at 1 for frequencies &gt; <code>a</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/pid_design.jl#L164-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.leadlink" href="#ControlSystems.leadlink"><code>ControlSystems.leadlink</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>leadlink(b, N, K; h=0)</code></p><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω = b√(N)</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>b</code> and level out at <code>KN</code> for frequencies &gt; <code>bN</code></p><p>The phase advance at <code>ω = b√(N)</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlinkat</code> <code>laglink</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/pid_design.jl#L178-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.leadlinkat" href="#ControlSystems.leadlinkat"><code>ControlSystems.leadlinkat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>leadlinkat(ω, N, K; h=0)</code></p><p>Returns a phase advancing link, the top of the phase curve is located at <code>ω</code> where the link amplification is <code>K√(N)</code> The bode curve will go from <code>K</code>, bend up at <code>ω/√(N)</code> and level out at <code>KN</code> for frequencies &gt; <code>ω√(N)</code></p><p>The phase advance at <code>ω</code> can be plotted as a function of <code>N</code> with <code>leadlinkcurve()</code></p><p>Values of <code>N &lt; 1</code> will give a phase retarding link.</p><p>See also <code>leadlink</code> <code>laglink</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/pid_design.jl#L198-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.loopshapingPI" href="#ControlSystems.loopshapingPI"><code>ControlSystems.loopshapingPI</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>kp,ki,C = loopshapingPI(P,ωp; ϕl,rl, phasemargin)</code></p><p>Selects the parameters of a PI-controller such that the Nyquist curve of <code>P</code> at the frequency <code>ωp</code> is moved to <code>rl exp(i ϕl)</code></p><p>If <code>phasemargin</code> is supplied, <code>ϕl</code> is selected such that the curve is moved to an angle of <code>phasemargin - 180</code> degrees</p><p>If no <code>rl</code> is given, the magnitude of the curve at <code>ωp</code> is kept the same and only the phase is affected, the same goes for <code>ϕl</code> if no phasemargin is given.</p><p>See also <code>pidplots</code>, <code>stabregionPID</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/pid_design.jl#L268-L278">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.lqr" href="#ControlSystems.lqr"><code>ControlSystems.lqr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>lqr(A, B, Q, R)</code></p><p>Calculate the optimal gain matrix <code>K</code> for the state-feedback law <code>u = K*x</code> that minimizes the cost function:</p><p>J = integral(x&#39;Qx + u&#39;Ru, 0, inf).</p><p>For the continuous time model <code>dx = Ax + Bu</code>.</p><p><code>lqr(sys, Q, R)</code></p><p>Solve the LQR problem for state-space system <code>sys</code>. Works for both discrete and continuous time systems.</p><p>See also <code>LQG</code></p><p>Usage example:</p><pre><code class="language-julia">using LinearAlgebra # For identity matrix I
A = [0 1; 0 0]
B = [0;1]
C = [1 0]
sys = ss(A,B,C,0)
Q = I
R = I
L = lqr(sys,Q,R)

u(t,x) = -L*x # Form control law,
t=0:0.1:5
x0 = [1,0]
y, t, x, uout = lsim(sys,u,t,x0)
plot(t,x, lab=[&quot;Position&quot;, &quot;Velocity&quot;]&#39;, xlabel=&quot;Time [s]&quot;)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/synthesis.jl#L1-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.pid" href="#ControlSystems.pid"><code>ControlSystems.pid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates and returns a PID controller on transfer function form. <code>time</code> indicates whether or not the parameters are given as gains (default) or as time constants <code>series</code> indicates  whether or not the series form or parallel form (default) is desired</p><p><code>C = pid(; kp=0, ki=0; kd=0, time=false, series=false)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/pid_design.jl#L3-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.place" href="#ControlSystems.place"><code>ControlSystems.place</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p><code>place(A, B, p)</code>, <code>place(sys::StateSpace, p)</code></p><p>Calculate gain matrix <code>K</code> such that the poles of <code>(A-BK)</code> in are in <code>p</code>.</p><p>Uses Ackermann&#39;s formula.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/synthesis.jl#L114-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.reduce_sys" href="#ControlSystems.reduce_sys"><code>ControlSystems.reduce_sys</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Implements REDUCE in the Emami-Naeini &amp; Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/analysis.jl#L237-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.rstc" href="#ControlSystems.rstc"><code>ControlSystems.rstc</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>See ?rstd for the discerte case</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/discrete.jl#L69-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ControlSystems.rstd" href="#ControlSystems.rstd"><code>ControlSystems.rstd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>rstd  Polynomial synthesis in discrete time.</p><p><code>R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)</code></p><p><code>R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)</code></p><p><code>R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO)</code></p><p>Polynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)</p><p>Inputs:  BPLUS  : Part of open loop numerator BMINUS : Part of open loop numerator A      : Open loop denominator BM1    : Additional zeros AM     : Closed loop denominator AO     : Observer polynomial AR     : Pre-specified factor of R, e.g integral part [1, -1]^k AS     : Pre-specified factor of S, e.g notch filter [1, 0, w^2]</p><p>Outputs: R,S,T  : Polynomials in controller</p><p>See function DAB how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.</p><p>See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan Åström, Björn Wittenmark</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaControl/ControlSystems.jl/blob/721654c2a508ae490af53656801f1fc8eed696af/src/discrete.jl#L74-L104">source</a></section><footer><hr/><a class="previous" href="../analysis/"><span class="direction">Previous</span><span class="title">Analysis</span></a><a class="next" href="../timefreqresponse/"><span class="direction">Next</span><span class="title">Time and Frequency response</span></a></footer></article></body></html>
