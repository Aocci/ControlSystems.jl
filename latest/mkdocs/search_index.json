{
    "docs": [
        {
            "location": "/", 
            "text": "ControlSystems.jl Manual\n\n\nA guide\n\n\n\n\nGuide\n\n\n\n\nExamples\n\n\n\n\nPID design functions\n\n\nAdvanced pole-zero placement\n\n\nStability boundary for PID controllers\n\n\nPID plots\n\n\n\n\n\n\nFunctions\n\n\n\n\nConstructors\n\n\nPlotting functions\n\n\n\n\n\n\nDocumentation Index\n\n\n\n\nControlSystems.tf\n\n\nControlSystems.zpk\n\n\nControlSystems.bodeplot\n\n\nControlSystems.impulseplot\n\n\nControlSystems.nicholsplot\n\n\nControlSystems.stepplot", 
            "title": "Home"
        }, 
        {
            "location": "/#controlsystemsjl-manual", 
            "text": "A guide", 
            "title": "ControlSystems.jl Manual"
        }, 
        {
            "location": "/#guide", 
            "text": "", 
            "title": "Guide"
        }, 
        {
            "location": "/#examples", 
            "text": "PID design functions  Advanced pole-zero placement  Stability boundary for PID controllers  PID plots", 
            "title": "Examples"
        }, 
        {
            "location": "/#functions", 
            "text": "Constructors  Plotting functions", 
            "title": "Functions"
        }, 
        {
            "location": "/#documentation-index", 
            "text": "ControlSystems.tf  ControlSystems.zpk  ControlSystems.bodeplot  ControlSystems.impulseplot  ControlSystems.nicholsplot  ControlSystems.stepplot", 
            "title": "Documentation Index"
        }, 
        {
            "location": "/examples/example/", 
            "text": "PID design functions\n\n\nBy plotting the gang of four under unit feedback for the process\n\n\nP = tf(1,[1,1])^4\ngangoffourplot(P,tf(1))\n\n\n\n\n\n\nwe notice that the sensitivity function is a bit too high at around frequencies \u03c9 = 0.8 rad/s. Since we want to control the process using a simple PI-controller, we utilize the function \nloopshapingPI\n and tell it that we want 60 degrees phase margin at this frequency. The resulting gang of four is plotted for both the constructed controller and for unit feedback.\n\n\n\u03c9p = 0.8\nkp,ki,C = loopshapingPI(P,\u03c9p,phasemargin=60, doplot=true)\n\n\n\n\n \n\n\nWe could also cosider a situation where we want to create a closed-loop system with the bandwidth \u03c9 = 2 rad/s, in which case we would write something like\n\n\n\u03c9p = 2\nkp,ki,C60 = loopshapingPI(P,\u03c9p,rl=1,phasemargin=60, doplot=true)\n\n\n\n\nHere we specify that we want the Nyquist curve \nL(i\u03c9) = P(i\u03c9)C(i\u03c9)\n to pass the point \n|L(i\u03c9)| = rl = 1,  arg(L(i\u03c9)) = -180 + phasemargin = -180 + 60\n The gang of four tells us that we can indeed get a very robust and fast controller with this design method, but it will cost us significant control action to double the bandwidth of all four poles. \n \n\n\n\n\nAdvanced pole-zero placement\n\n\nThis example illustrates how we can perform advanced pole-zero placement. The task is to make the process a bit faster and damp the poorly damped poles.\n\n\nDefine the process\n\n\n\u03b6 = 0.2\n\u03c9 = 1\n\nB = [1]\nA   = [1, 2\u03b6*\u03c9, \u03c9^2]\nP  = tf(B,A)\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 0.4s + 1.0\n\nContinuous-time transfer function model\n\n\n\n\nDefine the desired closed loop response, calculate the controller polynomials and simulate the closed-loop system. The design utilizes an observer poles twice as fast as the closed-loop poles. An additional observer pole is added in order to get a casual controller when an integrator is added to the controller.\n\n\n# Control design\n\u03b60 = 0.7\n\u03c90 = 2\nAm = [1, 2\u03b60*\u03c90, \u03c90^2]\nAo = conv(2Am, [1/2, 1]) # Observer polynomial, add extra pole due to the integrator\nAR = [1,0] # Force the controller to contain an integrator ( 1/(s+0) )\n\nB\u207a  = [1] # The process numerator polynomial can be facored as B = B\u207aB\u207b where B\u207b contains the zeros we do not want to cancel (non-minimum phase and poorly damped zeros)\nB\u207b  = [1]\nBm  = conv(B\u207a, B\u207b) # In this case, keep the entire numerator polynomial of the process\n\nR,S,T = rstc(B\u207a,B\u207b,A,Bm,Am,Ao,AR) # Calculate the 2-DOF controller polynomials\n\nGcl = tf(conv(B,T),zpconv(A,R,B,S)) # Form the closed loop polynomial from reference to output, the closed-loop characteristic polynomial is AR + BS, the function zpconv takes care of the polynomial multiplication and makes sure the coefficient vectores are of equal length\n\nstepplot([P,Gcl]) # Visualize the open and closed loop responses.\ngangoffourplot(P, tf(-S,R)) # Plot the gang of four to check that all tranfer functions are OK\n\n\n\n\n \n\n\n\n\nStability boundary for PID controllers\n\n\nThe stability boundary, where the transfer function \nP(s)C(s) = -1\n, can be plotted with the command \nstabregionPID\n. The process can be given in string form or as a regular LTIsystem.\n\n\nP1 = \nexp(-sqrt(s))\n\nf1 = stabregionPID(P1,logspace(-5,1,1000))\nP2 = \n100*(s+6).^2./(s.*(s+1).^2.*(s+50).^2)\n\nf2 = stabregionPID(P2,logspace(-5,2,1000))\nP3 = tf(1,[1,1])^4\nf3 = stabregionPID(P3,logspace(-5,0,1000))\n\n\n\n\n \n \n\n\n\n\nPID plots\n\n\nThis example utilizes the function \npidplots\n, which accepts vectors of PID-parameters and produces relevant plots. The task is to take a system with bandwidth 1 rad/s and produce a closed-loop system with bandwidth 0.1 rad/s. If one is not careful and proceed with pole placement, one easily get a system with very poor robustness.\n\n\nP = tf([1.],[1., 1])\n\n\u03b6 = 0.5 # Desired damping\n\nws = logspace(-1,2,8) # A vector of closed-loop bandwidths\nkp = 2*\u03b6*ws-1 # Simple pole placement with PI given the closed-loop bandwidth, the poles are placed in a butterworth pattern\nki = ws.^2\npidplots(P,:nyquist,:gof;kps=kp,kis=ki, \u03c9= logspace(-2,2,500)) # Request Nyquist and Gang-of-four plots (more plots are available, see ?pidplots )\n\n\n\n\n \n\n\nNow try a different strategy, where we have specified a gain crossover frequency of 0.1 rad/s\n\n\nkp = linspace(-1,1,8) #\nki = sqrt(1-kp.^2)/10\npidplots(P,:nyquist,:gof;kps=kp,kis=ki)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/example/#pid-design-functions", 
            "text": "By plotting the gang of four under unit feedback for the process  P = tf(1,[1,1])^4\ngangoffourplot(P,tf(1))   we notice that the sensitivity function is a bit too high at around frequencies \u03c9 = 0.8 rad/s. Since we want to control the process using a simple PI-controller, we utilize the function  loopshapingPI  and tell it that we want 60 degrees phase margin at this frequency. The resulting gang of four is plotted for both the constructed controller and for unit feedback.  \u03c9p = 0.8\nkp,ki,C = loopshapingPI(P,\u03c9p,phasemargin=60, doplot=true)     We could also cosider a situation where we want to create a closed-loop system with the bandwidth \u03c9 = 2 rad/s, in which case we would write something like  \u03c9p = 2\nkp,ki,C60 = loopshapingPI(P,\u03c9p,rl=1,phasemargin=60, doplot=true)  Here we specify that we want the Nyquist curve  L(i\u03c9) = P(i\u03c9)C(i\u03c9)  to pass the point  |L(i\u03c9)| = rl = 1,  arg(L(i\u03c9)) = -180 + phasemargin = -180 + 60  The gang of four tells us that we can indeed get a very robust and fast controller with this design method, but it will cost us significant control action to double the bandwidth of all four poles.", 
            "title": "PID design functions"
        }, 
        {
            "location": "/examples/example/#advanced-pole-zero-placement", 
            "text": "This example illustrates how we can perform advanced pole-zero placement. The task is to make the process a bit faster and damp the poorly damped poles.  Define the process  \u03b6 = 0.2\n\u03c9 = 1\n\nB = [1]\nA   = [1, 2\u03b6*\u03c9, \u03c9^2]\nP  = tf(B,A)\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 0.4s + 1.0\n\nContinuous-time transfer function model  Define the desired closed loop response, calculate the controller polynomials and simulate the closed-loop system. The design utilizes an observer poles twice as fast as the closed-loop poles. An additional observer pole is added in order to get a casual controller when an integrator is added to the controller.  # Control design\n\u03b60 = 0.7\n\u03c90 = 2\nAm = [1, 2\u03b60*\u03c90, \u03c90^2]\nAo = conv(2Am, [1/2, 1]) # Observer polynomial, add extra pole due to the integrator\nAR = [1,0] # Force the controller to contain an integrator ( 1/(s+0) )\n\nB\u207a  = [1] # The process numerator polynomial can be facored as B = B\u207aB\u207b where B\u207b contains the zeros we do not want to cancel (non-minimum phase and poorly damped zeros)\nB\u207b  = [1]\nBm  = conv(B\u207a, B\u207b) # In this case, keep the entire numerator polynomial of the process\n\nR,S,T = rstc(B\u207a,B\u207b,A,Bm,Am,Ao,AR) # Calculate the 2-DOF controller polynomials\n\nGcl = tf(conv(B,T),zpconv(A,R,B,S)) # Form the closed loop polynomial from reference to output, the closed-loop characteristic polynomial is AR + BS, the function zpconv takes care of the polynomial multiplication and makes sure the coefficient vectores are of equal length\n\nstepplot([P,Gcl]) # Visualize the open and closed loop responses.\ngangoffourplot(P, tf(-S,R)) # Plot the gang of four to check that all tranfer functions are OK", 
            "title": "Advanced pole-zero placement"
        }, 
        {
            "location": "/examples/example/#stability-boundary-for-pid-controllers", 
            "text": "The stability boundary, where the transfer function  P(s)C(s) = -1 , can be plotted with the command  stabregionPID . The process can be given in string form or as a regular LTIsystem.  P1 =  exp(-sqrt(s)) \nf1 = stabregionPID(P1,logspace(-5,1,1000))\nP2 =  100*(s+6).^2./(s.*(s+1).^2.*(s+50).^2) \nf2 = stabregionPID(P2,logspace(-5,2,1000))\nP3 = tf(1,[1,1])^4\nf3 = stabregionPID(P3,logspace(-5,0,1000))", 
            "title": "Stability boundary for PID controllers"
        }, 
        {
            "location": "/examples/example/#pid-plots", 
            "text": "This example utilizes the function  pidplots , which accepts vectors of PID-parameters and produces relevant plots. The task is to take a system with bandwidth 1 rad/s and produce a closed-loop system with bandwidth 0.1 rad/s. If one is not careful and proceed with pole placement, one easily get a system with very poor robustness.  P = tf([1.],[1., 1])\n\n\u03b6 = 0.5 # Desired damping\n\nws = logspace(-1,2,8) # A vector of closed-loop bandwidths\nkp = 2*\u03b6*ws-1 # Simple pole placement with PI given the closed-loop bandwidth, the poles are placed in a butterworth pattern\nki = ws.^2\npidplots(P,:nyquist,:gof;kps=kp,kis=ki, \u03c9= logspace(-2,2,500)) # Request Nyquist and Gang-of-four plots (more plots are available, see ?pidplots )     Now try a different strategy, where we have specified a gain crossover frequency of 0.1 rad/s  kp = linspace(-1,1,8) #\nki = sqrt(1-kp.^2)/10\npidplots(P,:nyquist,:gof;kps=kp,kis=ki)", 
            "title": "PID plots"
        }, 
        {
            "location": "/man/introduction/", 
            "text": "Introduction\n\n\n\n\nInstallation\n\n\nTo install this package simply run\n\n\nPkg.add(\nControlSystems\n)\n\n\n\n\n\n\nBasic functions\n\n\n\n\nPlotting\n\n\nPlotting requires some extra care. The ControlSystems package is using \nPlots.jl\n as interface to generate all the plots. This means that the user is able to freely choose back-end. The plots in this manual are generated using \nPyPlot\n. If you have several back-ends for plotting then you can select the one you want to use with the corresponding \nPlots\n call (for \nPyPlot\n this is \nPlots.pyplot()\n, some alternatives are \nimmerse(), gadfly(), plotly()\n). A simple example where we generate a plot using \nimmerse\n and save it to a file is\n\n\nusing ControlSystems\nPlots.immerse()\n\nfig = bodeplot(tf(1,[1,2,1]))\n\nPlots.savefig(fig, \nmyfile.svg\n)", 
            "title": "Introduction"
        }, 
        {
            "location": "/man/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/man/introduction/#installation", 
            "text": "To install this package simply run  Pkg.add( ControlSystems )", 
            "title": "Installation"
        }, 
        {
            "location": "/man/introduction/#basic-functions", 
            "text": "", 
            "title": "Basic functions"
        }, 
        {
            "location": "/man/introduction/#plotting", 
            "text": "Plotting requires some extra care. The ControlSystems package is using  Plots.jl  as interface to generate all the plots. This means that the user is able to freely choose back-end. The plots in this manual are generated using  PyPlot . If you have several back-ends for plotting then you can select the one you want to use with the corresponding  Plots  call (for  PyPlot  this is  Plots.pyplot() , some alternatives are  immerse(), gadfly(), plotly() ). A simple example where we generate a plot using  immerse  and save it to a file is  using ControlSystems\nPlots.immerse()\n\nfig = bodeplot(tf(1,[1,2,1]))\n\nPlots.savefig(fig,  myfile.svg )", 
            "title": "Plotting"
        }, 
        {
            "location": "/man/creatingtfs/", 
            "text": "Creating Transfer Functions\n\n\n\n\ntf - Rational Representation\n\n\nThe syntax for creating a transfer function is\n\n\ntf(num, den, Ts=0)\n\n\n\n\nwhere \nnum\n and \nden\n are the polinomial coefficients of the numerator and denominator of the polynomial and \nTs\n is the sample time.\n\n\n\n\nExample:\n\n\ntf([1],[1,2,1])\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 2.0s + 1.0\n\nContinuous-time transfer function model\n\n\n\n\nThe transfer functions created using this method will be of type \nTransferFunction{SisoRational}\n.\n\n\n\n\nzpk - Pole-Zero-Gain Representation\n\n\nSometimes it's better to represent the transferfunction by its poles, zeros and gain, this can be done using\n\n\nzpk(zeros, poles, gain, Ts=0)\n\n\n\n\nwhere \nzeros\n and \npoles\n are \nVectors\n of the zeros and poles for the system and \ngain\n is a gain coefficient.\n\n\n\n\nExample\n\n\nzpk([-1,1], [-5, -10], 2)\n\n# output\n\nTransferFunction:\n   (s - 1.0)(s + 1.0)\n2.0-------------------\n   (s + 10.0)(s + 5.0)\n\nContinuous-time transfer function model\n\n\n\n\nThe transfer functions created using this method will be of type \nTransferFunction{SisoZpk}\n.\n\n\n\n\ntfa - Generalized Representation\n\n\nIf you want to work with transfer functions that are not rational functions, it is possible to use the \ntfa\n representation\n\n\ntfa(str::String), tfa(str::Expr)\n\n\n\n\nThis function will either convert \nstr\n to an expression or directly accept an \nExpr\n and create a transfer function.\n\n\n\n\nExample:\n\n\ntfa(\n1/((s+1)*exp(-sqrt(s)))\n)\n\n## output\n\nTransferFunction:\n1/((s+1)*exp(-sqrt(s)))\n\nContinuous-time transfer function model\n\n\n\n\nThe transfer functions created using this method will be of type \nTransferFunction{SisoGeneralized}\n. This type will work with some functions like \nbodeplot, stepplot\n but not others ,like \npoles\n.\n\n\n\n\nConverting between types\n\n\nIt is sometime useful to convert one representation to another, this is possible using the same functions, for example\n\n\ntf(zpk([-1], [1], 2, 0.1))\n\n# output\n\nTransferFunction:\n2.0z + 2.0\n----------\n z - 1.0\n\nSample Time: 0.1 (seconds)\nDiscrete-time transfer function model", 
            "title": "Creating Transfer Functions"
        }, 
        {
            "location": "/man/creatingtfs/#creating-transfer-functions", 
            "text": "", 
            "title": "Creating Transfer Functions"
        }, 
        {
            "location": "/man/creatingtfs/#tf-rational-representation", 
            "text": "The syntax for creating a transfer function is  tf(num, den, Ts=0)  where  num  and  den  are the polinomial coefficients of the numerator and denominator of the polynomial and  Ts  is the sample time.", 
            "title": "tf - Rational Representation"
        }, 
        {
            "location": "/man/creatingtfs/#example", 
            "text": "tf([1],[1,2,1])\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 2.0s + 1.0\n\nContinuous-time transfer function model  The transfer functions created using this method will be of type  TransferFunction{SisoRational} .", 
            "title": "Example:"
        }, 
        {
            "location": "/man/creatingtfs/#zpk-pole-zero-gain-representation", 
            "text": "Sometimes it's better to represent the transferfunction by its poles, zeros and gain, this can be done using  zpk(zeros, poles, gain, Ts=0)  where  zeros  and  poles  are  Vectors  of the zeros and poles for the system and  gain  is a gain coefficient.", 
            "title": "zpk - Pole-Zero-Gain Representation"
        }, 
        {
            "location": "/man/creatingtfs/#example_1", 
            "text": "zpk([-1,1], [-5, -10], 2)\n\n# output\n\nTransferFunction:\n   (s - 1.0)(s + 1.0)\n2.0-------------------\n   (s + 10.0)(s + 5.0)\n\nContinuous-time transfer function model  The transfer functions created using this method will be of type  TransferFunction{SisoZpk} .", 
            "title": "Example"
        }, 
        {
            "location": "/man/creatingtfs/#tfa-generalized-representation", 
            "text": "If you want to work with transfer functions that are not rational functions, it is possible to use the  tfa  representation  tfa(str::String), tfa(str::Expr)  This function will either convert  str  to an expression or directly accept an  Expr  and create a transfer function.", 
            "title": "tfa - Generalized Representation"
        }, 
        {
            "location": "/man/creatingtfs/#example_2", 
            "text": "tfa( 1/((s+1)*exp(-sqrt(s))) )\n\n## output\n\nTransferFunction:\n1/((s+1)*exp(-sqrt(s)))\n\nContinuous-time transfer function model  The transfer functions created using this method will be of type  TransferFunction{SisoGeneralized} . This type will work with some functions like  bodeplot, stepplot  but not others ,like  poles .", 
            "title": "Example:"
        }, 
        {
            "location": "/man/creatingtfs/#converting-between-types", 
            "text": "It is sometime useful to convert one representation to another, this is possible using the same functions, for example  tf(zpk([-1], [1], 2, 0.1))\n\n# output\n\nTransferFunction:\n2.0z + 2.0\n----------\n z - 1.0\n\nSample Time: 0.1 (seconds)\nDiscrete-time transfer function model", 
            "title": "Converting between types"
        }, 
        {
            "location": "/lib/plotting/", 
            "text": "ControlSystems.bodeplot\n\n\nControlSystems.impulseplot\n\n\nControlSystems.nicholsplot\n\n\nControlSystems.stepplot\n\n\n\n\n\n\nPlotting functions\n\n\n#\n\n\nControlSystems.bodeplot\n \n \nFunction\n.\n\n\n\n\nbodeplot(sys, args...)\n, \nbodeplot(LTISystem[sys1, sys2...], args...; plotphase=true)\n\n\nCreate a Bode plot of the \nLTISystem\n(s). A frequency vector \nw\n can be optionally provided.\n\n\n#\n\n\nControlSystems.stepplot\n \n \nFunction\n.\n\n\n\n\nstepplot(sys, args...)\n, \nstepplot(LTISystem[sys1, sys2...], args...)\n\n\nPlot the \nstep\n response of the \nLTISystem\n(s). A final time \nTf\n or a time vector \nt\n can be optionally provided.\n\n\n#\n\n\nControlSystems.impulseplot\n \n \nFunction\n.\n\n\n\n\nimpulseplot(sys, args...)\n, \nimpulseplot(LTISystem[sys1, sys2...], args...)\n\n\nPlot the \nimpulse\n response of the \nLTISystem\n(s). A final time \nTf\n or a time vector \nt\n can be optionally provided.\n\n\n#\n\n\nControlSystems.nicholsplot\n \n \nFunction\n.\n\n\n\n\nnicholsplot{T\n:LTISystem}(systems::Vector{T}, w::AbstractVector)\n\n\nCreate a Nichols plot of the \nLTISystem\n(s). A frequency vector \nw\n can be optionally provided.\n\n\nKeyword arguments:\n\n\ntext = true\nGains = [12, 6, 3, 1, 0.5, -0.5, -1, -3, -6, -10, -20, -40, -60]\npInc = 30\nsat = 0.4\nval = 0.85\nfontsize = 10\n\n\n\n\npInc\n determines the increment in degrees between phase lines.\n\n\nsat\n \u2208 [0,1] determines the saturation of the gain lines\n\n\nval\n \u2208 [0,1] determines the brightness of the gain lines\n\n\nAdditional keyword arguments are sent to the function plotting the systems and can be used to specify colors, line styles etc. using regular Plots.jl syntax\n\n\nThis function is based on code subject to the two-clause BSD licence Copyright 2011 Will Robertson Copyright 2011 Philipp Allgeuer", 
            "title": "Plotting"
        }, 
        {
            "location": "/lib/plotting/#plotting-functions", 
            "text": "#  ControlSystems.bodeplot     Function .   bodeplot(sys, args...) ,  bodeplot(LTISystem[sys1, sys2...], args...; plotphase=true)  Create a Bode plot of the  LTISystem (s). A frequency vector  w  can be optionally provided.  #  ControlSystems.stepplot     Function .   stepplot(sys, args...) ,  stepplot(LTISystem[sys1, sys2...], args...)  Plot the  step  response of the  LTISystem (s). A final time  Tf  or a time vector  t  can be optionally provided.  #  ControlSystems.impulseplot     Function .   impulseplot(sys, args...) ,  impulseplot(LTISystem[sys1, sys2...], args...)  Plot the  impulse  response of the  LTISystem (s). A final time  Tf  or a time vector  t  can be optionally provided.  #  ControlSystems.nicholsplot     Function .   nicholsplot{T :LTISystem}(systems::Vector{T}, w::AbstractVector)  Create a Nichols plot of the  LTISystem (s). A frequency vector  w  can be optionally provided.  Keyword arguments:  text = true\nGains = [12, 6, 3, 1, 0.5, -0.5, -1, -3, -6, -10, -20, -40, -60]\npInc = 30\nsat = 0.4\nval = 0.85\nfontsize = 10  pInc  determines the increment in degrees between phase lines.  sat  \u2208 [0,1] determines the saturation of the gain lines  val  \u2208 [0,1] determines the brightness of the gain lines  Additional keyword arguments are sent to the function plotting the systems and can be used to specify colors, line styles etc. using regular Plots.jl syntax  This function is based on code subject to the two-clause BSD licence Copyright 2011 Will Robertson Copyright 2011 Philipp Allgeuer", 
            "title": "Plotting functions"
        }, 
        {
            "location": "/lib/constructors/", 
            "text": "ControlSystems.tf\n\n\nControlSystems.zpk\n\n\n\n\n\n\nConstructors\n\n\n#\n\n\nControlSystems.tf\n \n \nFunction\n.\n\n\n\n\ntf(num, den, Ts=0; kwargs...), tf(gain, Ts=0; kwargs...)\n Create transfer function as a fraction of polynomials:\n\n\nsys = numerator/denominator\n\n\nnum\n: the coefficients of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.\n\n\nden\n: the coefficients of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.\n\n\nTs\n: Sample time or \n0\n for continuous system.\n\n\nkwargs\n: \ninputnames\n, \noutputnames\n: Arrays of strings representing the inputs and outputs.\n\n\nOther uses:\n\n\ntf(sys)\n: Convert \nsys\n to \ntf\n form.\n\n\ntf(\"s\")\n, \ntf(\"z\")\n: Create the continous transferfunction \ns\n.\n\n\n#\n\n\nControlSystems.zpk\n \n \nFunction\n.\n\n\n\n\nzpk(gain, Ts=0; kwargs...), zpk(num, den, k, Ts=0; kwargs...), zpk(sys)\n Create transfer function on zero pole gain form. The numerator and denominator are represented by their poles and zeros.\n\n\nsys = k*numerator/denominator\n\n\nnum\n: the roots of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.\n\n\nden\n: the roots of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.\n\n\nk\n: The gain of the system. Obs, this is not the same as \ndcgain\n.\n\n\nTs\n: Sample time or \n0\n for continuous system.\n\n\nkwargs\n: \ninputnames\n, \noutputnames\n: Arrays of strings representing the inputs and outputs.\n\n\nOther uses:\n\n\ntf(sys)\n: Convert \nsys\n to \ntf\n form.\n\n\ntf(\"s\")\n: Create the transferfunction \ns\n.", 
            "title": "Constructors"
        }, 
        {
            "location": "/lib/constructors/#constructors", 
            "text": "#  ControlSystems.tf     Function .   tf(num, den, Ts=0; kwargs...), tf(gain, Ts=0; kwargs...)  Create transfer function as a fraction of polynomials:  sys = numerator/denominator  num : the coefficients of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.  den : the coefficients of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.  Ts : Sample time or  0  for continuous system.  kwargs :  inputnames ,  outputnames : Arrays of strings representing the inputs and outputs.  Other uses:  tf(sys) : Convert  sys  to  tf  form.  tf(\"s\") ,  tf(\"z\") : Create the continous transferfunction  s .  #  ControlSystems.zpk     Function .   zpk(gain, Ts=0; kwargs...), zpk(num, den, k, Ts=0; kwargs...), zpk(sys)  Create transfer function on zero pole gain form. The numerator and denominator are represented by their poles and zeros.  sys = k*numerator/denominator  num : the roots of the numerator polynomial. Either scalar or vector to create SISO systems or an array of vectors to create MIMO system.  den : the roots of the denominator polynomial. Either vector to create SISO systems or an array of vectors to create MIMO system.  k : The gain of the system. Obs, this is not the same as  dcgain .  Ts : Sample time or  0  for continuous system.  kwargs :  inputnames ,  outputnames : Arrays of strings representing the inputs and outputs.  Other uses:  tf(sys) : Convert  sys  to  tf  form.  tf(\"s\") : Create the transferfunction  s .", 
            "title": "Constructors"
        }
    ]
}