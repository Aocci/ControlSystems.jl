{
    "docs": [
        {
            "location": "/", 
            "text": "ControlSystems.jl Manual\n\n\n\n\nExamples\n\n\n\n\nLQR design\n\n\nLQR design\n\n\nPID design functions\n\n\nAdvanced pole-zero placement\n\n\nStability boundary for PID controllers\n\n\nPID plots\n\n\n\n\n\n\nGuide\n\n\n\n\nIntroduction\n\n\nCreating Transfer Functions\n\n\n\n\n\n\nFunctions\n\n\n\n\nConstructing transfer functions\n\n\nPlotting functions\n\n\n\n\n\n\nDocumentation Index\n\n\n\n\nControlSystems.append\n\n\nControlSystems.c2d\n\n\nControlSystems.feedback\n\n\nControlSystems.feedback2dof\n\n\nControlSystems.minreal\n\n\nControlSystems.parallel\n\n\nControlSystems.series\n\n\nControlSystems.sminreal\n\n\nControlSystems.ss\n\n\nControlSystems.tf\n\n\nControlSystems.zpk\n\n\nControlSystems.bodeplot\n\n\nControlSystems.gangoffourplot\n\n\nControlSystems.impulseplot\n\n\nControlSystems.leadlinkcurve\n\n\nControlSystems.lsimplot\n\n\nControlSystems.marginplot\n\n\nControlSystems.nicholsplot\n\n\nControlSystems.nyquistplot\n\n\nControlSystems.pidplots\n\n\nControlSystems.pzmap\n\n\nControlSystems.rlocus\n\n\nControlSystems.setPlotScale\n\n\nControlSystems.sigmaplot\n\n\nControlSystems.stepplot\n\n\nBase.step\n\n\nControlSystems.bode\n\n\nControlSystems.evalfr\n\n\nControlSystems.freqresp\n\n\nControlSystems.impulse\n\n\nControlSystems.nyquist\n\n\nBase.LinAlg.norm\n\n\nControlSystems.covar\n\n\nControlSystems.ctrb\n\n\nControlSystems.damp\n\n\nControlSystems.dampreport\n\n\nControlSystems.dcgain\n\n\nControlSystems.delaymargin\n\n\nControlSystems.gangoffour\n\n\nControlSystems.gangofseven\n\n\nControlSystems.gram\n\n\nControlSystems.margin\n\n\nControlSystems.markovparam\n\n\nControlSystems.obsv\n\n\nControlSystems.pole\n\n\nControlSystems.sigma\n\n\nControlSystems.stabregionPID\n\n\nControlSystems.tzero\n\n\nControlSystems.zpkdata", 
            "title": "Home"
        }, 
        {
            "location": "/#controlsystemsjl-manual", 
            "text": "", 
            "title": "ControlSystems.jl Manual"
        }, 
        {
            "location": "/#examples", 
            "text": "LQR design  LQR design  PID design functions  Advanced pole-zero placement  Stability boundary for PID controllers  PID plots", 
            "title": "Examples"
        }, 
        {
            "location": "/#guide", 
            "text": "Introduction  Creating Transfer Functions", 
            "title": "Guide"
        }, 
        {
            "location": "/#functions", 
            "text": "Constructing transfer functions  Plotting functions", 
            "title": "Functions"
        }, 
        {
            "location": "/#documentation-index", 
            "text": "ControlSystems.append  ControlSystems.c2d  ControlSystems.feedback  ControlSystems.feedback2dof  ControlSystems.minreal  ControlSystems.parallel  ControlSystems.series  ControlSystems.sminreal  ControlSystems.ss  ControlSystems.tf  ControlSystems.zpk  ControlSystems.bodeplot  ControlSystems.gangoffourplot  ControlSystems.impulseplot  ControlSystems.leadlinkcurve  ControlSystems.lsimplot  ControlSystems.marginplot  ControlSystems.nicholsplot  ControlSystems.nyquistplot  ControlSystems.pidplots  ControlSystems.pzmap  ControlSystems.rlocus  ControlSystems.setPlotScale  ControlSystems.sigmaplot  ControlSystems.stepplot  Base.step  ControlSystems.bode  ControlSystems.evalfr  ControlSystems.freqresp  ControlSystems.impulse  ControlSystems.nyquist  Base.LinAlg.norm  ControlSystems.covar  ControlSystems.ctrb  ControlSystems.damp  ControlSystems.dampreport  ControlSystems.dcgain  ControlSystems.delaymargin  ControlSystems.gangoffour  ControlSystems.gangofseven  ControlSystems.gram  ControlSystems.margin  ControlSystems.markovparam  ControlSystems.obsv  ControlSystems.pole  ControlSystems.sigma  ControlSystems.stabregionPID  ControlSystems.tzero  ControlSystems.zpkdata", 
            "title": "Documentation Index"
        }, 
        {
            "location": "/examples/example/", 
            "text": "LQR design\n\n\nh       = 0.1\nA       = [1 h; 0 1]\nB       = [0;1]\nC       = [1 0]\nsys     = ss(A,B,C,0, h)\nQ       = eye(2)\nR       = eye(1)\nL       = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(t,x)  = -L*x + 1.5(t\n=2.5)# Form control law (u is a function of t and x), a constant input disturbance is affecting the system from t\u22672.5\nt       =0:h:5\nx0      = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[\nPosition\n, \nVelocity\n]', xlabel=\nTime [s]\n)\n\n\n\n\n\n\n\n\nLQR design\n\n\nh       = 0.1\nA       = [1 h; 0 1]\nB       = [0;1]\nC       = [1 0]\nsys     = ss(A,B,C,0, h)\nQ       = eye(2)\nR       = eye(1)\nL       = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(t,x)  = -L*x + 1.5(t\n=2.5)# Form control law (u is a function of t and x), a constant input disturbance is affecting the system from t\u22672.5\nt       =0:h:5\nx0      = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[\nPosition\n, \nVelocity\n]', xlabel=\nTime [s]\n)\n\n\n\n\n\n\n\n\nPID design functions\n\n\nBy plotting the gang of four under unit feedback for the process\n\n\nP = tf(1,[1,1])^4\ngangoffourplot(P,tf(1))\n\n\n\n\n\n\nwe notice that the sensitivity function is a bit too high at around frequencies \u03c9 = 0.8 rad/s. Since we want to control the process using a simple PI-controller, we utilize the function \nloopshapingPI\n and tell it that we want 60 degrees phase margin at this frequency. The resulting gang of four is plotted for both the constructed controller and for unit feedback.\n\n\n\u03c9p = 0.8\nkp,ki,C = loopshapingPI(P,\u03c9p,phasemargin=60, doplot=true)\n\n\n\n\n \n\n\nWe could also cosider a situation where we want to create a closed-loop system with the bandwidth \u03c9 = 2 rad/s, in which case we would write something like\n\n\n\u03c9p = 2\nkp,ki,C60 = loopshapingPI(P,\u03c9p,rl=1,phasemargin=60, doplot=true)\n\n\n\n\nHere we specify that we want the Nyquist curve \nL(i\u03c9) = P(i\u03c9)C(i\u03c9)\n to pass the point \n|L(i\u03c9)| = rl = 1,  arg(L(i\u03c9)) = -180 + phasemargin = -180 + 60\n The gang of four tells us that we can indeed get a very robust and fast controller with this design method, but it will cost us significant control action to double the bandwidth of all four poles. \n \n\n\n\n\nAdvanced pole-zero placement\n\n\nThis example illustrates how we can perform advanced pole-zero placement. The task is to make the process a bit faster and damp the poorly damped poles.\n\n\nDefine the process\n\n\n\u03b6 = 0.2\n\u03c9 = 1\n\nB = [1]\nA   = [1, 2\u03b6*\u03c9, \u03c9^2]\nP  = tf(B,A)\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 0.4s + 1.0\n\nContinuous-time transfer function model\n\n\n\n\nDefine the desired closed loop response, calculate the controller polynomials and simulate the closed-loop system. The design utilizes an observer poles twice as fast as the closed-loop poles. An additional observer pole is added in order to get a casual controller when an integrator is added to the controller.\n\n\n# Control design\n\u03b60 = 0.7\n\u03c90 = 2\nAm = [1, 2\u03b60*\u03c90, \u03c90^2]\nAo = conv(2Am, [1/2, 1]) # Observer polynomial, add extra pole due to the integrator\nAR = [1,0] # Force the controller to contain an integrator ( 1/(s+0) )\n\nB\u207a  = [1] # The process numerator polynomial can be facored as B = B\u207aB\u207b where B\u207b contains the zeros we do not want to cancel (non-minimum phase and poorly damped zeros)\nB\u207b  = [1]\nBm  = conv(B\u207a, B\u207b) # In this case, keep the entire numerator polynomial of the process\n\nR,S,T = rstc(B\u207a,B\u207b,A,Bm,Am,Ao,AR) # Calculate the 2-DOF controller polynomials\n\nGcl = tf(conv(B,T),zpconv(A,R,B,S)) # Form the closed loop polynomial from reference to output, the closed-loop characteristic polynomial is AR + BS, the function zpconv takes care of the polynomial multiplication and makes sure the coefficient vectores are of equal length\n\nstepplot([P,Gcl]) # Visualize the open and closed loop responses.\ngangoffourplot(P, tf(-S,R)) # Plot the gang of four to check that all tranfer functions are OK\n\n\n\n\n \n\n\n\n\nStability boundary for PID controllers\n\n\nThe stability boundary, where the transfer function \nP(s)C(s) = -1\n, can be plotted with the command \nstabregionPID\n. The process can be given in string form or as a regular LTIsystem.\n\n\nP1 = \nexp(-sqrt(s))\n\nf1 = stabregionPID(P1,logspace(-5,1,1000))\nP2 = \n100*(s+6).^2./(s.*(s+1).^2.*(s+50).^2)\n\nf2 = stabregionPID(P2,logspace(-5,2,1000))\nP3 = tf(1,[1,1])^4\nf3 = stabregionPID(P3,logspace(-5,0,1000))\n\n\n\n\n \n \n\n\n\n\nPID plots\n\n\nThis example utilizes the function \npidplots\n, which accepts vectors of PID-parameters and produces relevant plots. The task is to take a system with bandwidth 1 rad/s and produce a closed-loop system with bandwidth 0.1 rad/s. If one is not careful and proceed with pole placement, one easily get a system with very poor robustness.\n\n\nP = tf([1.],[1., 1])\n\n\u03b6 = 0.5 # Desired damping\n\nws = logspace(-1,2,8) # A vector of closed-loop bandwidths\nkp = 2*\u03b6*ws-1 # Simple pole placement with PI given the closed-loop bandwidth, the poles are placed in a butterworth pattern\nki = ws.^2\npidplots(P,:nyquist,:gof;kps=kp,kis=ki, \u03c9= logspace(-2,2,500)) # Request Nyquist and Gang-of-four plots (more plots are available, see ?pidplots )\n\n\n\n\n \n\n\nNow try a different strategy, where we have specified a gain crossover frequency of 0.1 rad/s\n\n\nkp = linspace(-1,1,8) #\nki = sqrt(1-kp.^2)/10\npidplots(P,:nyquist,:gof;kps=kp,kis=ki)", 
            "title": "Design"
        }, 
        {
            "location": "/examples/example/#lqr-design", 
            "text": "h       = 0.1\nA       = [1 h; 0 1]\nB       = [0;1]\nC       = [1 0]\nsys     = ss(A,B,C,0, h)\nQ       = eye(2)\nR       = eye(1)\nL       = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(t,x)  = -L*x + 1.5(t =2.5)# Form control law (u is a function of t and x), a constant input disturbance is affecting the system from t\u22672.5\nt       =0:h:5\nx0      = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[ Position ,  Velocity ]', xlabel= Time [s] )", 
            "title": "LQR design"
        }, 
        {
            "location": "/examples/example/#lqr-design_1", 
            "text": "h       = 0.1\nA       = [1 h; 0 1]\nB       = [0;1]\nC       = [1 0]\nsys     = ss(A,B,C,0, h)\nQ       = eye(2)\nR       = eye(1)\nL       = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(t,x)  = -L*x + 1.5(t =2.5)# Form control law (u is a function of t and x), a constant input disturbance is affecting the system from t\u22672.5\nt       =0:h:5\nx0      = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[ Position ,  Velocity ]', xlabel= Time [s] )", 
            "title": "LQR design"
        }, 
        {
            "location": "/examples/example/#pid-design-functions", 
            "text": "By plotting the gang of four under unit feedback for the process  P = tf(1,[1,1])^4\ngangoffourplot(P,tf(1))   we notice that the sensitivity function is a bit too high at around frequencies \u03c9 = 0.8 rad/s. Since we want to control the process using a simple PI-controller, we utilize the function  loopshapingPI  and tell it that we want 60 degrees phase margin at this frequency. The resulting gang of four is plotted for both the constructed controller and for unit feedback.  \u03c9p = 0.8\nkp,ki,C = loopshapingPI(P,\u03c9p,phasemargin=60, doplot=true)     We could also cosider a situation where we want to create a closed-loop system with the bandwidth \u03c9 = 2 rad/s, in which case we would write something like  \u03c9p = 2\nkp,ki,C60 = loopshapingPI(P,\u03c9p,rl=1,phasemargin=60, doplot=true)  Here we specify that we want the Nyquist curve  L(i\u03c9) = P(i\u03c9)C(i\u03c9)  to pass the point  |L(i\u03c9)| = rl = 1,  arg(L(i\u03c9)) = -180 + phasemargin = -180 + 60  The gang of four tells us that we can indeed get a very robust and fast controller with this design method, but it will cost us significant control action to double the bandwidth of all four poles.", 
            "title": "PID design functions"
        }, 
        {
            "location": "/examples/example/#advanced-pole-zero-placement", 
            "text": "This example illustrates how we can perform advanced pole-zero placement. The task is to make the process a bit faster and damp the poorly damped poles.  Define the process  \u03b6 = 0.2\n\u03c9 = 1\n\nB = [1]\nA   = [1, 2\u03b6*\u03c9, \u03c9^2]\nP  = tf(B,A)\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 0.4s + 1.0\n\nContinuous-time transfer function model  Define the desired closed loop response, calculate the controller polynomials and simulate the closed-loop system. The design utilizes an observer poles twice as fast as the closed-loop poles. An additional observer pole is added in order to get a casual controller when an integrator is added to the controller.  # Control design\n\u03b60 = 0.7\n\u03c90 = 2\nAm = [1, 2\u03b60*\u03c90, \u03c90^2]\nAo = conv(2Am, [1/2, 1]) # Observer polynomial, add extra pole due to the integrator\nAR = [1,0] # Force the controller to contain an integrator ( 1/(s+0) )\n\nB\u207a  = [1] # The process numerator polynomial can be facored as B = B\u207aB\u207b where B\u207b contains the zeros we do not want to cancel (non-minimum phase and poorly damped zeros)\nB\u207b  = [1]\nBm  = conv(B\u207a, B\u207b) # In this case, keep the entire numerator polynomial of the process\n\nR,S,T = rstc(B\u207a,B\u207b,A,Bm,Am,Ao,AR) # Calculate the 2-DOF controller polynomials\n\nGcl = tf(conv(B,T),zpconv(A,R,B,S)) # Form the closed loop polynomial from reference to output, the closed-loop characteristic polynomial is AR + BS, the function zpconv takes care of the polynomial multiplication and makes sure the coefficient vectores are of equal length\n\nstepplot([P,Gcl]) # Visualize the open and closed loop responses.\ngangoffourplot(P, tf(-S,R)) # Plot the gang of four to check that all tranfer functions are OK", 
            "title": "Advanced pole-zero placement"
        }, 
        {
            "location": "/examples/example/#stability-boundary-for-pid-controllers", 
            "text": "The stability boundary, where the transfer function  P(s)C(s) = -1 , can be plotted with the command  stabregionPID . The process can be given in string form or as a regular LTIsystem.  P1 =  exp(-sqrt(s)) \nf1 = stabregionPID(P1,logspace(-5,1,1000))\nP2 =  100*(s+6).^2./(s.*(s+1).^2.*(s+50).^2) \nf2 = stabregionPID(P2,logspace(-5,2,1000))\nP3 = tf(1,[1,1])^4\nf3 = stabregionPID(P3,logspace(-5,0,1000))", 
            "title": "Stability boundary for PID controllers"
        }, 
        {
            "location": "/examples/example/#pid-plots", 
            "text": "This example utilizes the function  pidplots , which accepts vectors of PID-parameters and produces relevant plots. The task is to take a system with bandwidth 1 rad/s and produce a closed-loop system with bandwidth 0.1 rad/s. If one is not careful and proceed with pole placement, one easily get a system with very poor robustness.  P = tf([1.],[1., 1])\n\n\u03b6 = 0.5 # Desired damping\n\nws = logspace(-1,2,8) # A vector of closed-loop bandwidths\nkp = 2*\u03b6*ws-1 # Simple pole placement with PI given the closed-loop bandwidth, the poles are placed in a butterworth pattern\nki = ws.^2\npidplots(P,:nyquist,:gof;kps=kp,kis=ki, \u03c9= logspace(-2,2,500)) # Request Nyquist and Gang-of-four plots (more plots are available, see ?pidplots )     Now try a different strategy, where we have specified a gain crossover frequency of 0.1 rad/s  kp = linspace(-1,1,8) #\nki = sqrt(1-kp.^2)/10\npidplots(P,:nyquist,:gof;kps=kp,kis=ki)", 
            "title": "PID plots"
        }, 
        {
            "location": "/man/introduction/", 
            "text": "Introduction\n\n\n\n\nInstallation\n\n\nTo install this package simply run\n\n\nPkg.add(\nControlSystems\n)\n\n\n\n\n\n\nBasic functions\n\n\nTransfer functions can easily be created using the function \ntf(num, den, Ts=0)\n, where \nnum\n and \nden\n are vectors representing the numerator and denominator of a rational function. See \ntf\n or the section \"Creating Transfer Functions\" for more info. These functions can then be connected and modified using the operators \n+,-,*,/\n and functions like \nappend\n.\n\n\nExample:\n\n\nP = tf([1],[1,1])\nT = P/(1+P)\n\n# output\n\nTransferFunction:\n    s + 1.0\n----------------\ns^2 + 3.0s + 2.0\n\nContinuous-time transfer function model\n\n\n\n\nNotice that the poles are not canceled automatically, to do this, the function \nminreal\n is available\n\n\nminreal(T)\n\n# output\n\nTransferFunction:\n  1.0\n-------\ns + 2.0\n\nContinuous-time transfer function model\n\n\n\n\n\n\nPlotting\n\n\nPlotting requires some extra care. The ControlSystems package is using \nPlots.jl\n (\nlink\n) as interface to generate all the plots. This means that the user is able to freely choose back-end. The plots in this manual are generated using \nPyPlot\n. If you have several back-ends for plotting then you can select the one you want to use with the corresponding \nPlots\n call (for \nPyPlot\n this is \nPlots.pyplot()\n, some alternatives are \nimmerse(), gadfly(), plotly()\n). A simple example where we generate a plot using \nimmerse\n and save it to a file is\n\n\nusing ControlSystems\nPlots.immerse()\n\nfig = bodeplot(tf(1,[1,2,1]))\n\nPlots.savefig(fig, \nmyfile.svg\n)", 
            "title": "Introduction"
        }, 
        {
            "location": "/man/introduction/#introduction", 
            "text": "", 
            "title": "Introduction"
        }, 
        {
            "location": "/man/introduction/#installation", 
            "text": "To install this package simply run  Pkg.add( ControlSystems )", 
            "title": "Installation"
        }, 
        {
            "location": "/man/introduction/#basic-functions", 
            "text": "Transfer functions can easily be created using the function  tf(num, den, Ts=0) , where  num  and  den  are vectors representing the numerator and denominator of a rational function. See  tf  or the section \"Creating Transfer Functions\" for more info. These functions can then be connected and modified using the operators  +,-,*,/  and functions like  append .  Example:  P = tf([1],[1,1])\nT = P/(1+P)\n\n# output\n\nTransferFunction:\n    s + 1.0\n----------------\ns^2 + 3.0s + 2.0\n\nContinuous-time transfer function model  Notice that the poles are not canceled automatically, to do this, the function  minreal  is available  minreal(T)\n\n# output\n\nTransferFunction:\n  1.0\n-------\ns + 2.0\n\nContinuous-time transfer function model", 
            "title": "Basic functions"
        }, 
        {
            "location": "/man/introduction/#plotting", 
            "text": "Plotting requires some extra care. The ControlSystems package is using  Plots.jl  ( link ) as interface to generate all the plots. This means that the user is able to freely choose back-end. The plots in this manual are generated using  PyPlot . If you have several back-ends for plotting then you can select the one you want to use with the corresponding  Plots  call (for  PyPlot  this is  Plots.pyplot() , some alternatives are  immerse(), gadfly(), plotly() ). A simple example where we generate a plot using  immerse  and save it to a file is  using ControlSystems\nPlots.immerse()\n\nfig = bodeplot(tf(1,[1,2,1]))\n\nPlots.savefig(fig,  myfile.svg )", 
            "title": "Plotting"
        }, 
        {
            "location": "/man/creatingtfs/", 
            "text": "Creating Transfer Functions\n\n\n\n\ntf - Rational Representation\n\n\nThe syntax for creating a transfer function is\n\n\ntf(num, den, Ts=0)\n\n\n\n\nwhere \nnum\n and \nden\n are the polinomial coefficients of the numerator and denominator of the polynomial and \nTs\n is the sample time.\n\n\n\n\nExample:\n\n\ntf([1],[1,2,1])\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 2.0s + 1.0\n\nContinuous-time transfer function model\n\n\n\n\nThe transfer functions created using this method will be of type \nTransferFunction{SisoRational}\n.\n\n\n\n\nzpk - Pole-Zero-Gain Representation\n\n\nSometimes it's better to represent the transferfunction by its poles, zeros and gain, this can be done using\n\n\nzpk(zeros, poles, gain, Ts=0)\n\n\n\n\nwhere \nzeros\n and \npoles\n are \nVectors\n of the zeros and poles for the system and \ngain\n is a gain coefficient.\n\n\n\n\nExample\n\n\nzpk([-1,1], [-5, -10], 2)\n\n# output\n\nTransferFunction:\n   (s - 1.0)(s + 1.0)\n2.0-------------------\n   (s + 10.0)(s + 5.0)\n\nContinuous-time transfer function model\n\n\n\n\nThe transfer functions created using this method will be of type \nTransferFunction{SisoZpk}\n.\n\n\n\n\nConverting between types\n\n\nIt is sometime useful to convert one representation to another, this is possible using the same functions, for example\n\n\ntf(zpk([-1], [1], 2, 0.1))\n\n# output\n\nTransferFunction:\n2.0z + 2.0\n----------\n z - 1.0\n\nSample Time: 0.1 (seconds)\nDiscrete-time transfer function model", 
            "title": "Creating Transfer Functions"
        }, 
        {
            "location": "/man/creatingtfs/#creating-transfer-functions", 
            "text": "", 
            "title": "Creating Transfer Functions"
        }, 
        {
            "location": "/man/creatingtfs/#tf-rational-representation", 
            "text": "The syntax for creating a transfer function is  tf(num, den, Ts=0)  where  num  and  den  are the polinomial coefficients of the numerator and denominator of the polynomial and  Ts  is the sample time.", 
            "title": "tf - Rational Representation"
        }, 
        {
            "location": "/man/creatingtfs/#example", 
            "text": "tf([1],[1,2,1])\n\n# output\n\nTransferFunction:\n      1.0\n----------------\ns^2 + 2.0s + 1.0\n\nContinuous-time transfer function model  The transfer functions created using this method will be of type  TransferFunction{SisoRational} .", 
            "title": "Example:"
        }, 
        {
            "location": "/man/creatingtfs/#zpk-pole-zero-gain-representation", 
            "text": "Sometimes it's better to represent the transferfunction by its poles, zeros and gain, this can be done using  zpk(zeros, poles, gain, Ts=0)  where  zeros  and  poles  are  Vectors  of the zeros and poles for the system and  gain  is a gain coefficient.", 
            "title": "zpk - Pole-Zero-Gain Representation"
        }, 
        {
            "location": "/man/creatingtfs/#example_1", 
            "text": "zpk([-1,1], [-5, -10], 2)\n\n# output\n\nTransferFunction:\n   (s - 1.0)(s + 1.0)\n2.0-------------------\n   (s + 10.0)(s + 5.0)\n\nContinuous-time transfer function model  The transfer functions created using this method will be of type  TransferFunction{SisoZpk} .", 
            "title": "Example"
        }, 
        {
            "location": "/man/creatingtfs/#converting-between-types", 
            "text": "It is sometime useful to convert one representation to another, this is possible using the same functions, for example  tf(zpk([-1], [1], 2, 0.1))\n\n# output\n\nTransferFunction:\n2.0z + 2.0\n----------\n z - 1.0\n\nSample Time: 0.1 (seconds)\nDiscrete-time transfer function model", 
            "title": "Converting between types"
        }, 
        {
            "location": "/lib/constructors/", 
            "text": "ControlSystems.append\n\n\nControlSystems.c2d\n\n\nControlSystems.feedback\n\n\nControlSystems.feedback2dof\n\n\nControlSystems.minreal\n\n\nControlSystems.parallel\n\n\nControlSystems.series\n\n\nControlSystems.sminreal\n\n\nControlSystems.ss\n\n\nControlSystems.tf\n\n\nControlSystems.zpk\n\n\n\n\n\n\nConstructing transfer functions\n\n\nappend\nc2d\nfeedback\nfeedback2dof\nminreal\nparallel\nseries\nsminreal\nss\nss2tf\ntf\nzpk", 
            "title": "Constructors"
        }, 
        {
            "location": "/lib/constructors/#constructing-transfer-functions", 
            "text": "append\nc2d\nfeedback\nfeedback2dof\nminreal\nparallel\nseries\nsminreal\nss\nss2tf\ntf\nzpk", 
            "title": "Constructing transfer functions"
        }, 
        {
            "location": "/lib/analysis/", 
            "text": "Base.LinAlg.norm\n\n\nControlSystems.covar\n\n\nControlSystems.ctrb\n\n\nControlSystems.damp\n\n\nControlSystems.dampreport\n\n\nControlSystems.dcgain\n\n\nControlSystems.delaymargin\n\n\nControlSystems.gangoffour\n\n\nControlSystems.gangofseven\n\n\nControlSystems.gram\n\n\nControlSystems.margin\n\n\nControlSystems.markovparam\n\n\nControlSystems.obsv\n\n\nControlSystems.pole\n\n\nControlSystems.sigma\n\n\nControlSystems.stabregionPID\n\n\nControlSystems.tzero\n\n\nControlSystems.zpkdata\n\n\n\n\n\n\nAnalysis\n\n\n#\n\n\nControlSystems.covar\n \n \nFunction\n.\n\n\nP = covar(sys, W)\n\n\nCalculate the stationary covariance \nP = E[y(t)y(t)']\n of an lti-model \nsys\n, driven by gaussian white noise 'w' of covariance \nE[w(t)w(\u03c4)]=W*\u03b4(t-\u03c4)\n where \u03b4 is the dirac delta.\n\n\nThe ouput is if Inf if the system is unstable. Passing white noise directly to the output will result in infinite covariance in the corresponding outputs (D\nW\nD.' .!= 0) for contunuous systems.\n\n\nsource\n\n\n#\n\n\nControlSystems.ctrb\n \n \nFunction\n.\n\n\nctrb(A, B)\n or \nctrb(sys)\n\n\nCompute the controllability matrix for the system described by \n(A, B)\n or \nsys\n.\n\n\nNote that checking for controllability by computing the rank from \nctrb\n is not the most numerically accurate way, a better method is checking if \ngram(sys, :c)\n is positive definite.\n\n\nsource\n\n\n#\n\n\nControlSystems.damp\n \n \nFunction\n.\n\n\nWn, zeta, ps = damp(sys)\n\n\nCompute the natural frequencies, \nWn\n, and damping ratios, \nzeta\n, of the poles, \nps\n, of \nsys\n\n\nsource\n\n\n#\n\n\nControlSystems.dampreport\n \n \nFunction\n.\n\n\ndampreport(sys)\n\n\nDisplay a report of the poles, damping ratio, natural frequency, and time constant of the system \nsys\n\n\nsource\n\n\n#\n\n\nControlSystems.dcgain\n \n \nFunction\n.\n\n\ndcgain(sys)\n\n\nCompute the dcgain of system \nsys\n.\n\n\nequal to G(0) for continuous-time systems and G(1) for discrete-time systems.\n\n\nsource\n\n\n#\n\n\nControlSystems.delaymargin\n \n \nFunction\n.\n\n\nd\u2098 = delaymargin(G::LTISystem)\n\n\nOnly supports SISO systems\n\n\nsource\n\n\n#\n\n\nControlSystems.gangoffour\n \n \nFunction\n.\n\n\nS,D,N,T = gangoffour(P,C)\n, \ngangoffour(P::AbstractVector,C::AbstractVector)\n\n\nGiven a transfer function describing the Plant \nP\n and a transferfunction describing the controller \nC\n, computes the four transfer functions in the Gang-of-Four.\n\n\nS = 1/(1+PC)\n Sensitivity function\n\n\nD = P/(1+PC)\n\n\nN = C/(1+PC)\n\n\nT = PC/(1+PC)\n Complementary sensitivity function\n\n\nOnly supports SISO systems\n\n\nsource\n\n\n#\n\n\nControlSystems.gangofseven\n \n \nFunction\n.\n\n\nS, D, N, T, RY, RU, RE = gangofseven(P,C,F)\n\n\nGiven transfer functions describing the Plant \nP\n, the controller \nC\n and a feed forward block \nF\n, computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.\n\n\nS = 1/(1+PC)\n Sensitivity function\n\n\nD = P/(1+PC)\n\n\nN = C/(1+PC)\n\n\nT = PC/(1+PC)\n Complementary sensitivity function\n\n\nRY = PCF/(1+PC)\n\n\nRU = CF/(1+P*C)\n\n\nRE = F/(1+P*C)\n\n\nOnly supports SISO systems\n\n\nsource\n\n\n#\n\n\nControlSystems.gram\n \n \nFunction\n.\n\n\ngram(sys, opt)\n\n\nCompute the grammian of system \nsys\n. If \nopt\n is \n:c\n, computes the controllability grammian. If \nopt\n is \n:o\n, computes the observability grammian.\n\n\nsource\n\n\n#\n\n\nControlSystems.margin\n \n \nFunction\n.\n\n\n\u03c9g\u2098, g\u2098, \u03c9\u03d5\u2098, \u03d5\u2098 = margin{S\n:Real}(sys::LTISystem, w::AbstractVector{S}; full=false, allMargins=false)\n\n\nreturns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins\n\n\nIf \n!allMargins\n, return only the smallest margin\n\n\nIf \nfull\n return also \nfullPhase\n\n\nsource\n\n\n#\n\n\nControlSystems.markovparam\n \n \nFunction\n.\n\n\nmarkovparam(sys, n)\n\n\nCompute the \nn\nth markov parameter of state-space system \nsys\n. This is defined as the following:\n\n\nh(0) = D\n\n\nh(n) = C*A^(n-1)*B\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.norm\n \n \nFunction\n.\n\n\n..  norm(sys, p=2; tol=1e-6)\n\n\nnorm(sys)\n or \nnorm(sys,2)\n computes the H2 norm of the LTI system \nsys\n.\n\n\nnorm(sys, Inf)\n computes the L\u221e norm of the LTI system \nsys\n. The H\u221e norm is the same as the L\u221e for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function \nnorminf\n instead.\n\n\ntol\n is an optional keyword argument, used only for the computation of L\u221e norms. It represents the desired relative accuracy for the computed L\u221e norm (this is not an absolute certificate however).\n\n\nsys is first converted to a state space model if needed.\n\n\nThe L\u221e norm computation implements the 'two-step algorithm' in: N.A. Bruinsma and M. Steinbuch, 'A fast algorithm to compute the H\u221e-norm of a transfer function matrix', Systems and Control Letters 14 (1990), pp. 287-293. For the discrete-time version, see, e.g.,: P. Bongers, O. Bosgra, M. Steinbuch, 'L\u221e-norm calculation for generalized state space systems in continuous and discrete time', American Control Conference, 1991.\n\n\nsource\n\n\n#\n\n\nControlSystems.obsv\n \n \nFunction\n.\n\n\nobsv(A, C)\n or \nobsv(sys)\n\n\nCompute the observability matrix for the system described by \n(A, C)\n or \nsys\n.\n\n\nNote that checking for observability by computing the rank from \nobsv\n is not the most numerically accurate way, a better method is checking if \ngram(sys, :o)\n is positive definite.\n\n\nsource\n\n\n#\n\n\nControlSystems.pole\n \n \nFunction\n.\n\n\npole(sys)\n\n\nCompute the poles of system \nsys\n.\n\n\nsource\n\n\n#\n\n\nControlSystems.sigma\n \n \nFunction\n.\n\n\nsv, w = sigma(sys[, w])\n\n\nCompute the singular values of the frequency response of system \nsys\n at frequencies \nw\n\n\nsv\n has size \n(length(w), max(ny, nu))\n\n\nsource\n\n\n#\n\n\nControlSystems.stabregionPID\n \n \nFunction\n.\n\n\nfig, kp, ki = stabregionPID(P, [\u03c9]; kd=0, doplot = true)\n\n\nSegments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The PID controller is assumed to be on the form kp +ki/s +kd s\n\n\nThe curve is found by analyzing P(s)*C(s) = -1 \u27f9\n\n\n|PC| = |P| |C| = 1\n\n\narg(P) + arg(C) = -\u03c0\n\n\nIf \nP\n is a function (e.g. s -\n exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions\n\n\nSee also \nstabregionPID\n, \nloopshapingPI\n, \npidplots\n\n\nsource\n\n\n#\n\n\nControlSystems.tzero\n \n \nFunction\n.\n\n\ntzero(sys)\n\n\nCompute the invariant zeros of the system \nsys\n. If \nsys\n is a minimal realization, these are also the transmission zeros.\n\n\nsource\n\n\n#\n\n\nControlSystems.zpkdata\n \n \nFunction\n.\n\n\nz, p, k = zpkdata(sys)\n\n\nCompute the zeros, poles, and gains of system \nsys\n.\n\n\nReturns\n\n\nz\n : Matrix{Vector{Complex128}}, (ny x nu)\n\n\np\n : Matrix{Vector{Complex128}}, (ny x nu)\n\n\nk\n : Matrix{Float64}, (ny x nu)\n\n\nsource", 
            "title": "Analysis"
        }, 
        {
            "location": "/lib/analysis/#analysis", 
            "text": "#  ControlSystems.covar     Function .  P = covar(sys, W)  Calculate the stationary covariance  P = E[y(t)y(t)']  of an lti-model  sys , driven by gaussian white noise 'w' of covariance  E[w(t)w(\u03c4)]=W*\u03b4(t-\u03c4)  where \u03b4 is the dirac delta.  The ouput is if Inf if the system is unstable. Passing white noise directly to the output will result in infinite covariance in the corresponding outputs (D W D.' .!= 0) for contunuous systems.  source  #  ControlSystems.ctrb     Function .  ctrb(A, B)  or  ctrb(sys)  Compute the controllability matrix for the system described by  (A, B)  or  sys .  Note that checking for controllability by computing the rank from  ctrb  is not the most numerically accurate way, a better method is checking if  gram(sys, :c)  is positive definite.  source  #  ControlSystems.damp     Function .  Wn, zeta, ps = damp(sys)  Compute the natural frequencies,  Wn , and damping ratios,  zeta , of the poles,  ps , of  sys  source  #  ControlSystems.dampreport     Function .  dampreport(sys)  Display a report of the poles, damping ratio, natural frequency, and time constant of the system  sys  source  #  ControlSystems.dcgain     Function .  dcgain(sys)  Compute the dcgain of system  sys .  equal to G(0) for continuous-time systems and G(1) for discrete-time systems.  source  #  ControlSystems.delaymargin     Function .  d\u2098 = delaymargin(G::LTISystem)  Only supports SISO systems  source  #  ControlSystems.gangoffour     Function .  S,D,N,T = gangoffour(P,C) ,  gangoffour(P::AbstractVector,C::AbstractVector)  Given a transfer function describing the Plant  P  and a transferfunction describing the controller  C , computes the four transfer functions in the Gang-of-Four.  S = 1/(1+PC)  Sensitivity function  D = P/(1+PC)  N = C/(1+PC)  T = PC/(1+PC)  Complementary sensitivity function  Only supports SISO systems  source  #  ControlSystems.gangofseven     Function .  S, D, N, T, RY, RU, RE = gangofseven(P,C,F)  Given transfer functions describing the Plant  P , the controller  C  and a feed forward block  F , computes the four transfer functions in the Gang-of-Four and the transferfunctions corresponding to the feed forward.  S = 1/(1+PC)  Sensitivity function  D = P/(1+PC)  N = C/(1+PC)  T = PC/(1+PC)  Complementary sensitivity function  RY = PCF/(1+PC)  RU = CF/(1+P*C)  RE = F/(1+P*C)  Only supports SISO systems  source  #  ControlSystems.gram     Function .  gram(sys, opt)  Compute the grammian of system  sys . If  opt  is  :c , computes the controllability grammian. If  opt  is  :o , computes the observability grammian.  source  #  ControlSystems.margin     Function .  \u03c9g\u2098, g\u2098, \u03c9\u03d5\u2098, \u03d5\u2098 = margin{S :Real}(sys::LTISystem, w::AbstractVector{S}; full=false, allMargins=false)  returns frequencies for gain margins, gain margins, frequencies for phase margins, phase margins  If  !allMargins , return only the smallest margin  If  full  return also  fullPhase  source  #  ControlSystems.markovparam     Function .  markovparam(sys, n)  Compute the  n th markov parameter of state-space system  sys . This is defined as the following:  h(0) = D  h(n) = C*A^(n-1)*B  source  #  Base.LinAlg.norm     Function .  ..  norm(sys, p=2; tol=1e-6)  norm(sys)  or  norm(sys,2)  computes the H2 norm of the LTI system  sys .  norm(sys, Inf)  computes the L\u221e norm of the LTI system  sys . The H\u221e norm is the same as the L\u221e for stable systems, and Inf for unstable systems. If the peak gain frequency is required as well, use the function  norminf  instead.  tol  is an optional keyword argument, used only for the computation of L\u221e norms. It represents the desired relative accuracy for the computed L\u221e norm (this is not an absolute certificate however).  sys is first converted to a state space model if needed.  The L\u221e norm computation implements the 'two-step algorithm' in: N.A. Bruinsma and M. Steinbuch, 'A fast algorithm to compute the H\u221e-norm of a transfer function matrix', Systems and Control Letters 14 (1990), pp. 287-293. For the discrete-time version, see, e.g.,: P. Bongers, O. Bosgra, M. Steinbuch, 'L\u221e-norm calculation for generalized state space systems in continuous and discrete time', American Control Conference, 1991.  source  #  ControlSystems.obsv     Function .  obsv(A, C)  or  obsv(sys)  Compute the observability matrix for the system described by  (A, C)  or  sys .  Note that checking for observability by computing the rank from  obsv  is not the most numerically accurate way, a better method is checking if  gram(sys, :o)  is positive definite.  source  #  ControlSystems.pole     Function .  pole(sys)  Compute the poles of system  sys .  source  #  ControlSystems.sigma     Function .  sv, w = sigma(sys[, w])  Compute the singular values of the frequency response of system  sys  at frequencies  w  sv  has size  (length(w), max(ny, nu))  source  #  ControlSystems.stabregionPID     Function .  fig, kp, ki = stabregionPID(P, [\u03c9]; kd=0, doplot = true)  Segments of the curve generated by this program is the boundary of the stability region for a process with transfer function P(s) The PID controller is assumed to be on the form kp +ki/s +kd s  The curve is found by analyzing P(s)*C(s) = -1 \u27f9  |PC| = |P| |C| = 1  arg(P) + arg(C) = -\u03c0  If  P  is a function (e.g. s -  exp(-sqrt(s)) ), the stability of feedback loops using PI-controllers can be analyzed for processes with models with arbitrary analytic functions  See also  stabregionPID ,  loopshapingPI ,  pidplots  source  #  ControlSystems.tzero     Function .  tzero(sys)  Compute the invariant zeros of the system  sys . If  sys  is a minimal realization, these are also the transmission zeros.  source  #  ControlSystems.zpkdata     Function .  z, p, k = zpkdata(sys)  Compute the zeros, poles, and gains of system  sys .  Returns  z  : Matrix{Vector{Complex128}}, (ny x nu)  p  : Matrix{Vector{Complex128}}, (ny x nu)  k  : Matrix{Float64}, (ny x nu)  source", 
            "title": "Analysis"
        }, 
        {
            "location": "/lib/synthesis/", 
            "text": "ControlSystems.balance\n\n\nControlSystems.care\n\n\nControlSystems.dab\n\n\nControlSystems.dare\n\n\nControlSystems.dkalman\n\n\nControlSystems.dlqr\n\n\nControlSystems.dlyap\n\n\nControlSystems.kalman\n\n\nControlSystems.laglink\n\n\nControlSystems.leadlink\n\n\nControlSystems.leadlinkat\n\n\nControlSystems.loopshapingPI\n\n\nControlSystems.lqr\n\n\nControlSystems.pid\n\n\nControlSystems.place\n\n\nControlSystems.reduce_sys\n\n\nControlSystems.rstc\n\n\nControlSystems.rstd\n\n\n\n\n\n\nSynthesis\n\n\n#\n\n\nControlSystems.balance\n \n \nFunction\n.\n\n\nT, B = balance(A[, perm=true])\n\n\nCompute a similarity transform \nT\n resulting in \nB = T\\A*T\n such that the row and column norms of \nB\n are approximately equivalent. If \nperm=false\n, the transformation will only scale, and not permute \nA\n.\n\n\nsource\n\n\n#\n\n\nControlSystems.care\n \n \nFunction\n.\n\n\ncare(A, B, Q, R)\n\n\nCompute 'X', the solution to the continuous-time algebraic Riccati equation, defined as A'X + XA - (XB)R^-1(B'X) + Q = 0, where R is non-singular.\n\n\nAlgorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf\n\n\nsource\n\n\n#\n\n\nControlSystems.dab\n \n \nFunction\n.\n\n\nDAB   Solves the Diophantine-Aryabhatta-Bezout identity\n\n\nX,Y = DAB(A,B,C)\n\n\nAX + BY = C, where A, B, C, X and Y are polynomials and deg Y = deg A - 1.\n\n\nSee Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan \u00c5str\u00f6m, Bj\u00f6rn Wittenmark\n\n\nsource\n\n\n#\n\n\nControlSystems.dare\n \n \nFunction\n.\n\n\ndare(A, B, Q, R)\n\n\nCompute \nX\n, the solution to the discrete-time algebraic Riccati equation, defined as A'XA - X - (A'XB)(B'XB + R)^-1(B'XA) + Q = 0, where A and R are non-singular.\n\n\nAlgorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf\n\n\nsource\n\n\n#\n\n\nControlSystems.dkalman\n \n \nFunction\n.\n\n\ndkalman(A, C, R1, R2)\n kalman(sys, R1, R2)`\n\n\nCalculate the optimal Kalman gain for discrete time systems\n\n\nsource\n\n\n#\n\n\nControlSystems.dlqr\n \n \nFunction\n.\n\n\ndlqr(A, B, Q, R)\n, \ndlqr(sys, Q, R)\n\n\nCalculate the optimal gain matrix \nK\n for the state-feedback law \nu[k] = K*x[k]\n that minimizes the cost function:\n\n\nJ = sum(x'Qx + u'Ru, 0, inf).\n\n\nFor the discrte time model \nx[k+1] = Ax[k] + Bu[k]\n.\n\n\nSee also \nlqg\n\n\nUsage example:\n\n\nh = 0.1\nA = [1 h; 0 1]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0, h)\nQ = eye(2)\nR = eye(1)\nL = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(t,x) = -L*x # Form control law,\nt=0:h:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[\nPosition\n, \nVelocity\n]', xlabel=\nTime [s]\n)\n\n\n\n\nsource\n\n\n#\n\n\nControlSystems.dlyap\n \n \nFunction\n.\n\n\ndlyap(A, Q)\n\n\nCompute the solution \"X\" to the discrete Lyapunov equation \"AXA' - X + Q = 0\".\n\n\nsource\n\n\n#\n\n\nControlSystems.kalman\n \n \nFunction\n.\n\n\nkalman(A, C, R1, R2)\n kalman(sys, R1, R2)`\n\n\nCalculate the optimal Kalman gain\n\n\nSee also \nLQG\n\n\nsource\n\n\n#\n\n\nControlSystems.laglink\n \n \nFunction\n.\n\n\nlaglink(a, M; h=0)\n\n\nReturns a phase retarding link, the rule of thumb \na = 0.1\u03c9c\n guarantees less than 6 degrees phase margin loss. The bode curve will go from \nM\n, bend down at \na/M\n and level out at 1 for frequencies \n \na\n\n\nsource\n\n\n#\n\n\nControlSystems.leadlink\n \n \nFunction\n.\n\n\nleadlink(b, N, K; h=0)\n\n\nReturns a phase advancing link, the top of the phase curve is located at \n\u03c9 = b\u221a(N)\n where the link amplification is \nK\u221a(N)\n The bode curve will go from \nK\n, bend up at \nb\n and level out at \nKN\n for frequencies \n \nbN\n\n\nThe phase advance at \n\u03c9 = b\u221a(N)\n can be plotted as a function of \nN\n with \nleadlinkcurve()\n\n\nValues of \nN \n 1\n will give a phase retarding link.\n\n\nSee also \nleadlinkat\n \nlaglink\n\n\nsource\n\n\n#\n\n\nControlSystems.leadlinkat\n \n \nFunction\n.\n\n\nleadlinkat(\u03c9, N, K; h=0)\n\n\nReturns a phase advancing link, the top of the phase curve is located at \n\u03c9\n where the link amplification is \nK\u221a(N)\n The bode curve will go from \nK\n, bend up at \n\u03c9/\u221a(N)\n and level out at \nKN\n for frequencies \n \n\u03c9\u221a(N)\n\n\nThe phase advance at \n\u03c9\n can be plotted as a function of \nN\n with \nleadlinkcurve()\n\n\nValues of \nN \n 1\n will give a phase retarding link.\n\n\nSee also \nleadlink\n \nlaglink\n\n\nsource\n\n\n#\n\n\nControlSystems.loopshapingPI\n \n \nFunction\n.\n\n\nkp,ki,C = loopshapingPI(P,\u03c9p; \u03d5l,rl, phasemargin)\n\n\nSelects the parameters of a PI-controller such that the Nyquist curve of \nP\n at the frequency \n\u03c9p\n is moved to \nrl exp(i \u03d5l)\n\n\nIf \nphasemargin\n is supplied, \n\u03d5l\n is selected such that the curve is moved to an angle of \nphasemargin - 180\n degrees\n\n\nIf no \nrl\n is given, the magnitude of the curve at \n\u03c9p\n is kept the same and only the phase is affected, the same goes for \n\u03d5l\n if no phasemargin is given.\n\n\nSee also \npidplots\n, \nstabregionPID\n\n\nsource\n\n\n#\n\n\nControlSystems.lqr\n \n \nFunction\n.\n\n\nlqr(A, B, Q, R)\n\n\nCalculate the optimal gain matrix \nK\n for the state-feedback law \nu = K*x\n that minimizes the cost function:\n\n\nJ = integral(x'Qx + u'Ru, 0, inf).\n\n\nFor the continuous time model \ndx = Ax + Bu\n.\n\n\nlqr(sys, Q, R)\n\n\nSolve the LQR problem for state-space system \nsys\n. Works for both discrete and continuous time systems.\n\n\nSee also \nLQG\n\n\nUsage example:\n\n\nA = [0 1; 0 0]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0)\nQ = eye(2)\nR = eye(1)\nL = lqr(sys,Q,R)\n\nu(t,x) = -L*x # Form control law,\nt=0:0.1:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[\nPosition\n, \nVelocity\n]', xlabel=\nTime [s]\n)\n\n\n\n\nsource\n\n\n#\n\n\nControlSystems.pid\n \n \nFunction\n.\n\n\nCalculates and returns a PID controller on transfer function form. \ntime\n indicates whether or not the parameters are given as gains (default) or as time constants \nseries\n indicates  whether or not the series form or parallel form (default) is desired\n\n\nC = pid(; kp=0, ki=0; kd=0, time=false, series=false)\n\n\nsource\n\n\n#\n\n\nControlSystems.place\n \n \nFunction\n.\n\n\nplace(A, B, p)\n, \nplace(sys::StateSpace, p)\n\n\nCalculate gain matrix \nK\n such that the poles of \n(A-BK)\n in are in \np\n\n\nsource\n\n\n#\n\n\nControlSystems.reduce_sys\n \n \nFunction\n.\n\n\nImplements REDUCE in the Emami-Naeini \n Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.\n\n\nsource\n\n\n#\n\n\nControlSystems.rstc\n \n \nFunction\n.\n\n\nSee ?rstd for the discerte case\n\n\nsource\n\n\n#\n\n\nControlSystems.rstd\n \n \nFunction\n.\n\n\nrstd  Polynomial synthesis in discrete time.\n\n\nR,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)\n\n\nR,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)\n\n\nR,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO)\n\n\nPolynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)\n\n\nInputs:  BPLUS  : Part of open loop numerator BMINUS : Part of open loop numerator A      : Open loop denominator BM1    : Additional zeros AM     : Closed loop denominator AO     : Observer polynomial AR     : Pre-specified factor of R, e.g integral part [1, -1]^k AS     : Pre-specified factor of S, e.g notch filter [1, 0, w^2]\n\n\nOutputs: R,S,T  : Polynomials in controller\n\n\nSee function DAB how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.\n\n\nSee Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan \u00c5str\u00f6m, Bj\u00f6rn Wittenmark\n\n\nsource", 
            "title": "Synthesis"
        }, 
        {
            "location": "/lib/synthesis/#synthesis", 
            "text": "#  ControlSystems.balance     Function .  T, B = balance(A[, perm=true])  Compute a similarity transform  T  resulting in  B = T\\A*T  such that the row and column norms of  B  are approximately equivalent. If  perm=false , the transformation will only scale, and not permute  A .  source  #  ControlSystems.care     Function .  care(A, B, Q, R)  Compute 'X', the solution to the continuous-time algebraic Riccati equation, defined as A'X + XA - (XB)R^-1(B'X) + Q = 0, where R is non-singular.  Algorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf  source  #  ControlSystems.dab     Function .  DAB   Solves the Diophantine-Aryabhatta-Bezout identity  X,Y = DAB(A,B,C)  AX + BY = C, where A, B, C, X and Y are polynomials and deg Y = deg A - 1.  See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan \u00c5str\u00f6m, Bj\u00f6rn Wittenmark  source  #  ControlSystems.dare     Function .  dare(A, B, Q, R)  Compute  X , the solution to the discrete-time algebraic Riccati equation, defined as A'XA - X - (A'XB)(B'XB + R)^-1(B'XA) + Q = 0, where A and R are non-singular.  Algorithm taken from: Laub, \"A Schur Method for Solving Algebraic Riccati Equations.\" http://dspace.mit.edu/bitstream/handle/1721.1/1301/R-0859-05666488.pdf  source  #  ControlSystems.dkalman     Function .  dkalman(A, C, R1, R2)  kalman(sys, R1, R2)`  Calculate the optimal Kalman gain for discrete time systems  source  #  ControlSystems.dlqr     Function .  dlqr(A, B, Q, R) ,  dlqr(sys, Q, R)  Calculate the optimal gain matrix  K  for the state-feedback law  u[k] = K*x[k]  that minimizes the cost function:  J = sum(x'Qx + u'Ru, 0, inf).  For the discrte time model  x[k+1] = Ax[k] + Bu[k] .  See also  lqg  Usage example:  h = 0.1\nA = [1 h; 0 1]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0, h)\nQ = eye(2)\nR = eye(1)\nL = dlqr(A,B,Q,R) # lqr(sys,Q,R) can also be used\n\nu(t,x) = -L*x # Form control law,\nt=0:h:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[ Position ,  Velocity ]', xlabel= Time [s] )  source  #  ControlSystems.dlyap     Function .  dlyap(A, Q)  Compute the solution \"X\" to the discrete Lyapunov equation \"AXA' - X + Q = 0\".  source  #  ControlSystems.kalman     Function .  kalman(A, C, R1, R2)  kalman(sys, R1, R2)`  Calculate the optimal Kalman gain  See also  LQG  source  #  ControlSystems.laglink     Function .  laglink(a, M; h=0)  Returns a phase retarding link, the rule of thumb  a = 0.1\u03c9c  guarantees less than 6 degrees phase margin loss. The bode curve will go from  M , bend down at  a/M  and level out at 1 for frequencies    a  source  #  ControlSystems.leadlink     Function .  leadlink(b, N, K; h=0)  Returns a phase advancing link, the top of the phase curve is located at  \u03c9 = b\u221a(N)  where the link amplification is  K\u221a(N)  The bode curve will go from  K , bend up at  b  and level out at  KN  for frequencies    bN  The phase advance at  \u03c9 = b\u221a(N)  can be plotted as a function of  N  with  leadlinkcurve()  Values of  N   1  will give a phase retarding link.  See also  leadlinkat   laglink  source  #  ControlSystems.leadlinkat     Function .  leadlinkat(\u03c9, N, K; h=0)  Returns a phase advancing link, the top of the phase curve is located at  \u03c9  where the link amplification is  K\u221a(N)  The bode curve will go from  K , bend up at  \u03c9/\u221a(N)  and level out at  KN  for frequencies    \u03c9\u221a(N)  The phase advance at  \u03c9  can be plotted as a function of  N  with  leadlinkcurve()  Values of  N   1  will give a phase retarding link.  See also  leadlink   laglink  source  #  ControlSystems.loopshapingPI     Function .  kp,ki,C = loopshapingPI(P,\u03c9p; \u03d5l,rl, phasemargin)  Selects the parameters of a PI-controller such that the Nyquist curve of  P  at the frequency  \u03c9p  is moved to  rl exp(i \u03d5l)  If  phasemargin  is supplied,  \u03d5l  is selected such that the curve is moved to an angle of  phasemargin - 180  degrees  If no  rl  is given, the magnitude of the curve at  \u03c9p  is kept the same and only the phase is affected, the same goes for  \u03d5l  if no phasemargin is given.  See also  pidplots ,  stabregionPID  source  #  ControlSystems.lqr     Function .  lqr(A, B, Q, R)  Calculate the optimal gain matrix  K  for the state-feedback law  u = K*x  that minimizes the cost function:  J = integral(x'Qx + u'Ru, 0, inf).  For the continuous time model  dx = Ax + Bu .  lqr(sys, Q, R)  Solve the LQR problem for state-space system  sys . Works for both discrete and continuous time systems.  See also  LQG  Usage example:  A = [0 1; 0 0]\nB = [0;1]\nC = [1 0]\nsys = ss(A,B,C,0)\nQ = eye(2)\nR = eye(1)\nL = lqr(sys,Q,R)\n\nu(t,x) = -L*x # Form control law,\nt=0:0.1:5\nx0 = [1,0]\ny, t, x, uout = lsim(sys,u,t,x0)\nplot(t,x, lab=[ Position ,  Velocity ]', xlabel= Time [s] )  source  #  ControlSystems.pid     Function .  Calculates and returns a PID controller on transfer function form.  time  indicates whether or not the parameters are given as gains (default) or as time constants  series  indicates  whether or not the series form or parallel form (default) is desired  C = pid(; kp=0, ki=0; kd=0, time=false, series=false)  source  #  ControlSystems.place     Function .  place(A, B, p) ,  place(sys::StateSpace, p)  Calculate gain matrix  K  such that the poles of  (A-BK)  in are in  p  source  #  ControlSystems.reduce_sys     Function .  Implements REDUCE in the Emami-Naeini   Van Dooren paper. Returns transformed A, B, C, D matrices. These are empty if there are no zeros.  source  #  ControlSystems.rstc     Function .  See ?rstd for the discerte case  source  #  ControlSystems.rstd     Function .  rstd  Polynomial synthesis in discrete time.  R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR,AS)  R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO,AR)  R,S,T=rstd(BPLUS,BMINUS,A,BM1,AM,AO)  Polynomial synthesis according to CCS ch 10 to design a controller R(q) u(k) = T(q) r(k) - S(q) y(k)  Inputs:  BPLUS  : Part of open loop numerator BMINUS : Part of open loop numerator A      : Open loop denominator BM1    : Additional zeros AM     : Closed loop denominator AO     : Observer polynomial AR     : Pre-specified factor of R, e.g integral part [1, -1]^k AS     : Pre-specified factor of S, e.g notch filter [1, 0, w^2]  Outputs: R,S,T  : Polynomials in controller  See function DAB how the solution to the Diophantine- Aryabhatta-Bezout identity is chosen.  See Computer-Controlled Systems: Theory and Design, Third Edition Karl Johan \u00c5str\u00f6m, Bj\u00f6rn Wittenmark  source", 
            "title": "Synthesis"
        }, 
        {
            "location": "/lib/timefreqresponse/", 
            "text": "Base.step\n\n\nControlSystems.bode\n\n\nControlSystems.evalfr\n\n\nControlSystems.freqresp\n\n\nControlSystems.impulse\n\n\nControlSystems.nyquist\n\n\n\n\n\n\nTime and Frequency response\n\n\ncall\nbode\nevalfr\nfreqresp\nimpulse\nlsim\nnyquist\nstep", 
            "title": "Time and Frequency response"
        }, 
        {
            "location": "/lib/timefreqresponse/#time-and-frequency-response", 
            "text": "call\nbode\nevalfr\nfreqresp\nimpulse\nlsim\nnyquist\nstep", 
            "title": "Time and Frequency response"
        }, 
        {
            "location": "/lib/plotting/", 
            "text": "ControlSystems.bodeplot\n\n\nControlSystems.gangoffourplot\n\n\nControlSystems.impulseplot\n\n\nControlSystems.leadlinkcurve\n\n\nControlSystems.lsimplot\n\n\nControlSystems.marginplot\n\n\nControlSystems.nicholsplot\n\n\nControlSystems.nyquistplot\n\n\nControlSystems.pidplots\n\n\nControlSystems.pzmap\n\n\nControlSystems.rlocus\n\n\nControlSystems.setPlotScale\n\n\nControlSystems.sigmaplot\n\n\nControlSystems.stepplot\n\n\n\n\n\n\nPlotting functions\n\n\nbodeplot\ngangoffourplot\nimpulseplot\nleadlinkcurve\nlsimplot\nmarginplot\nnicholsplot\nnyquistplot\npidplots\npzmap\npzmap!\nrlocus\nsigmaplot\nsetPlotScale\nstepplot", 
            "title": "Plotting"
        }, 
        {
            "location": "/lib/plotting/#plotting-functions", 
            "text": "bodeplot\ngangoffourplot\nimpulseplot\nleadlinkcurve\nlsimplot\nmarginplot\nnicholsplot\nnyquistplot\npidplots\npzmap\npzmap!\nrlocus\nsigmaplot\nsetPlotScale\nstepplot", 
            "title": "Plotting functions"
        }
    ]
}